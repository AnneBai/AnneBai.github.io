---
layout: post
title: 再看函数和作用域
---

## 函数

### 函数的创建

函数可以通过函数声明和函数表达式创建, 使用构造函数Function也可以创建一个函数, 但不常用; 函数可以作为对象用来赋值给变量.
```
// 函数声明
function add(a, b) {
    return a + b;
}
// 函数表达式
const add = function (a, b) {
    return a + b;
}
```
### 函数的匿名和命名

当使用函数表达式创建函数时, 函数**不必要**有名称, 即"匿名函数", 但最佳实践推荐总是为函数命名, 这样有几个好处:

+ 便于运行时栈追踪, 没有名字的函数将都被显示为anonymous(), 无法区分;
+ 便于在函数中自引用, 如一般的递归, 或者事件处理器在出发后把自己解除绑定;
+ 拥有一个描述性的名称有利于代码自解释, 便于理解和维护.

### 关于按值传参

函数的参数是按值传递的, 这句话在初学JavaScript的时候理解的比较浅, 后来使用的多了, 又重新复习高程反复思考, 才觉得似乎更明白一些.

函数在创建时所声明的参数(形参)可以当作是在声明在函数局部作用域的变量; 调用函数时, JS引擎会自动把**对应位置**的实参赋值给形参, 用于函数内部其他步骤; 这个赋值过程就是"按值传参"的关键.

这里主要难懂的地方在于对象这种引用类型值作为参数的时候, 在函数内部所用的形参被赋值为对象实参之后实际上是指向那个对象的指针, 而不是对象本身. 比如:
```
function reset(obj) {
    obj = null; // 并不是把参数对象本身赋值为null, 只是把内部obj变量重新赋值了
    return obj;
}
const object = {
    a: 1,
}
reset(object); // null
// object本身没有影响
object // {a: 1}
```
当执行`reset(object)`时, 相当于执行以下步骤:
```
var obj = object // 调用函数时自动为参数赋值
obj = null // 该变量重置为null
return obj // 返回该变量值
```

不过如果在函数中执行类似`obj.a = 2`这样的代码, 相当于找到`obj.a`所在引用并为其赋值`2`, 此时object的属性a会被修改.

## 作用域
作用域就像闭合容器, 包含一些只有在本作用域或子级作用域中才能访问的标识符; 

ES6之前, 除了几种并不常用的关键字如with/catch/eval有特殊的作用域, JavaScript只有函数有自己的作用域, 普通的大括号是没有块级作用域的概念的; ES6中新增了`let`,`const`关键字声明变量,可以把变量限定在当前最近的块儿作用域之内(大括号也有效);

函数作用域中，所有变量都属于函数, 且贯穿整个函数始终都可以使用和重用, 可以在嵌套作用域中访问.

块级作用域的好处除了减少冲突和变量污染, 还有利于垃圾回收;(因为从块级作用域之外无法访问到其内的变量, 引擎便可以认为其中的变量已不再需要, 可以及时回收内存;而如果大量的变量存在当前作用域而又有一个闭包存在, 那这个作用域中所有的变量都将会保留)

```
for (var i = 0; i < 5; i++) {
	setTimeout(function(){console.log(i)}, 1000);
}
// 5个5
for (let i = 0; i < 5; i++) {
	setTimeout(function(){console.log(i)}, 1000);
}
// 0 1 2 3 4
```
使用let声明变量，会把这个变量限定在当前的块级作用域之内；等同于下面的写法：
```
{
	let j;
	for (j=0; j<10; j++) {
		let i = j; // 每次迭代都重新绑定
		console.log( i );
	}
}
```

> 词法作用域是编写时的，而动态作用域（和 this）是运行时的。词法作用域关心的是 函数在何处被声明，但是动态作用域关心的是函数 从何处 被调用。

这里需要区分"执行环境"和"作用域"之间的区别, 个人理解是:

作用域是静态的, 依据的是创建时的词法作用域;函数的作用域都有一个与之关联的活动变量, 包含所有该作用域内的局部变量和函数, 而一旦执行结束, 该执行环境就从栈弹出, 其变量对象在没有闭包引用的情况下也会处于等待被垃圾回收的状态.

而执行环境则是执行时的活动变量的别称. 函数在执行时其内部作用域在栈中作为当前活动的执行环境, 在其外部是由于栈的调用形成的外围执行环境. 栈底是全局执行环境; 执行环境反应函数的调用关系, 可以理解为动态作用域. 

> 每个函数都有自己的执行环境, 当执行流进入一个函数时, 函数的环境就会被推入一个环境栈中. 而在函数执行之后,栈将其环境弹出, 把控制权返还给之前的执行环境. (引自*JavaScript高级程序设计* p73)

ES6之前, `this`在普通函数中类似于动态作用域的规则, 依据调用栈而非词法作用域的嵌套关系来确定它所指向的对象; ES6中使用箭头函数, `this`绑定的行为有了很大不同.

> this实际上是在函数被调用时建立的绑定, 它指向什么完全由函数被调用的调用点来决定. (引自*你不了解JS*)

箭头函数自己是没有`this`的, 也可以理解为, 在箭头函数中this的绑定是根据(并非"指向")词法作用域, 即箭头函数创建时所在的作用域(所绑定的对象);

函数执行是在主线程的执行栈中, 由底层全局作用域开始, 经过层层调用关系到达当前函数执行的位置; 所谓的调用点, 是指位于当前执行中的函数之前的调用;

例如：
```
var flag = 0;
var obj = {
	flag: 1,
	tell: function () {
	    console.log("tell:", this.flag);
	},
	say: function () {
		setTimeout( function timer(){
			console.log("say:", this.flag);
		}, 0); 
	}
};
obj.say(); 
obj.tell(); // tell: 1 say: 0
```
timer函数本身作为定时任务放入定时队列，此时已经和原对象obj脱离关系，当再次进入执行栈执行的时候是简单调用,`this`默认绑定在全局作用域；

```
var obj = {
	flag: 1,
	say: function () {
		setTimeout(() => {
			console.log(this.flag)
		}, 0); 
	}
};
obj.say(); // 1 
```
箭头函数被创建时， 由于没有自身`this`, 取其外部包含函数的`this`(如果有，否则继续向外部找直到全局作用域)，由于外部函数say是作为obj的方法调用，其中`this`被绑定给obj, 所以不论箭头函数执行时环境如何，其中的`this`已经是设置好的--指向obj;

```
var flag = 0;
var obj = {
	flag: 1,
	say: () => {
		setTimeout(() => {
			console.log(this.flag)
		}, 0); 
	}
};

obj.say(); // 0 
```
箭头函数的外部函数也是箭头函数, 则会继续向外部作用域寻找`this`, (obj本身是普通对象,没有作用域概念),say函数外部就是全局对象，所以say和setTimeout中的匿名函数中的`this`都会绑定到全局对象;